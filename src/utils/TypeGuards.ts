// -----------------------
// WARNING - DO NOT modify the "is" methods of the TypeGuards class directly. It is code generated by createTypeGuardsUtility.ts
//
// Note: This file is excluded from code coverage reports because it's automatically maintained (low risk).
// -----------------------

/* tslint:disable */
import * as compiler from "./../compiler";
import {ts, SyntaxKind} from "./../typescript";

/**
 * Type guards for checking the type of a node.
 */
export class TypeGuards {
    private constructor() {
    }

    /**
     * Gets if the node has an expression.
     * @param node - Node to check.
     */
    static hasExpression(node: compiler.Node): node is compiler.Node & { getExpression(): compiler.Expression; } {
        // this method is manually maintained
        if ((node as any).getExpression == null)
            return false;
        return (node as any).getExpression() != null;
    }

    /**
     * Gets if the node has a name.
     * @param node - Node to check.
     */
    static hasName(node: compiler.Node): node is compiler.Node & { getName(): string; } {
        // this method is manually maintained
        if ((node as any).getName == null)
            return false;
        return typeof (node as any).getName() === "string";
    }

    /**
     * Gets if the node is an AbstractableNode.
     * @param node - Node to check.
     */
    static isAbstractableNode(node: compiler.Node): node is compiler.AbstractableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an AmbientableNode.
     * @param node - Node to check.
     */
    static isAmbientableNode(node: compiler.Node): node is compiler.AmbientableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ArgumentedNode.
     * @param node - Node to check.
     */
    static isArgumentedNode(node: compiler.Node): node is compiler.ArgumentedNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.CallExpression:
            case SyntaxKind.NewExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ArrayLiteralExpression.
     * @param node - Node to check.
     */
    static isArrayLiteralExpression(node: compiler.Node): node is compiler.ArrayLiteralExpression {
        switch (node.getKind()) {
            case SyntaxKind.ArrayLiteralExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ArrayTypeNode.
     * @param node - Node to check.
     */
    static isArrayTypeNode(node: compiler.Node): node is compiler.ArrayTypeNode {
        switch (node.getKind()) {
            case SyntaxKind.ArrayType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ArrowFunction.
     * @param node - Node to check.
     */
    static isArrowFunction(node: compiler.Node): node is compiler.ArrowFunction {
        switch (node.getKind()) {
            case SyntaxKind.ArrowFunction:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an AsExpression.
     * @param node - Node to check.
     */
    static isAsExpression(node: compiler.Node): node is compiler.AsExpression {
        switch (node.getKind()) {
            case SyntaxKind.AsExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an AsyncableNode.
     * @param node - Node to check.
     */
    static isAsyncableNode(node: compiler.Node): node is compiler.AsyncableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an AwaitExpression.
     * @param node - Node to check.
     */
    static isAwaitExpression(node: compiler.Node): node is compiler.AwaitExpression {
        switch (node.getKind()) {
            case SyntaxKind.AwaitExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an AwaitableNode.
     * @param node - Node to check.
     */
    static isAwaitableNode(node: compiler.Node): node is compiler.AwaitableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.ForOfStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a BinaryExpression.
     * @param node - Node to check.
     */
    static isBinaryExpression(node: compiler.Node): node is compiler.BinaryExpression {
        switch (node.getKind()) {
            case SyntaxKind.BinaryExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a BindingNamedNode.
     * @param node - Node to check.
     */
    static isBindingNamedNode(node: compiler.Node): node is compiler.BindingNamedNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a Block.
     * @param node - Node to check.
     */
    static isBlock(node: compiler.Node): node is compiler.Block {
        switch (node.getKind()) {
            case SyntaxKind.Block:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a BodiedNode.
     * @param node - Node to check.
     */
    static isBodiedNode(node: compiler.Node): node is compiler.BodiedNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.GetAccessor:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a BodyableNode.
     * @param node - Node to check.
     */
    static isBodyableNode(node: compiler.Node): node is compiler.BodyableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a BooleanLiteral.
     * @param node - Node to check.
     */
    static isBooleanLiteral(node: compiler.Node): node is compiler.BooleanLiteral {
        switch (node.getKind()) {
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a BreakStatement.
     * @param node - Node to check.
     */
    static isBreakStatement(node: compiler.Node): node is compiler.BreakStatement {
        switch (node.getKind()) {
            case SyntaxKind.BreakStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a CallExpression.
     * @param node - Node to check.
     */
    static isCallExpression(node: compiler.Node): node is compiler.CallExpression {
        switch (node.getKind()) {
            case SyntaxKind.CallExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a CallSignatureDeclaration.
     * @param node - Node to check.
     */
    static isCallSignatureDeclaration(node: compiler.Node): node is compiler.CallSignatureDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.CallSignature:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a CaseBlock.
     * @param node - Node to check.
     */
    static isCaseBlock(node: compiler.Node): node is compiler.CaseBlock {
        switch (node.getKind()) {
            case SyntaxKind.CaseBlock:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a CaseClause.
     * @param node - Node to check.
     */
    static isCaseClause(node: compiler.Node): node is compiler.CaseClause {
        switch (node.getKind()) {
            case SyntaxKind.CaseClause:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a CatchClause.
     * @param node - Node to check.
     */
    static isCatchClause(node: compiler.Node): node is compiler.CatchClause {
        switch (node.getKind()) {
            case SyntaxKind.CatchClause:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ChildOrderableNode.
     * @param node - Node to check.
     */
    static isChildOrderableNode(node: compiler.Node): node is compiler.ChildOrderableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.BreakStatement:
            case SyntaxKind.CaseClause:
            case SyntaxKind.ContinueStatement:
            case SyntaxKind.DefaultClause:
            case SyntaxKind.DoStatement:
            case SyntaxKind.ExpressionStatement:
            case SyntaxKind.ForInStatement:
            case SyntaxKind.ForOfStatement:
            case SyntaxKind.ForStatement:
            case SyntaxKind.IfStatement:
            case SyntaxKind.LabeledStatement:
            case SyntaxKind.ReturnStatement:
            case SyntaxKind.SwitchStatement:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.WhileStatement:
            case SyntaxKind.WithStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ClassDeclaration.
     * @param node - Node to check.
     */
    static isClassDeclaration(node: compiler.Node): node is compiler.ClassDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a CommaListExpression.
     * @param node - Node to check.
     */
    static isCommaListExpression(node: compiler.Node): node is compiler.CommaListExpression {
        switch (node.getKind()) {
            case SyntaxKind.CommaListExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ComputedPropertyName.
     * @param node - Node to check.
     */
    static isComputedPropertyName(node: compiler.Node): node is compiler.ComputedPropertyName {
        switch (node.getKind()) {
            case SyntaxKind.ComputedPropertyName:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ConditionalExpression.
     * @param node - Node to check.
     */
    static isConditionalExpression(node: compiler.Node): node is compiler.ConditionalExpression {
        switch (node.getKind()) {
            case SyntaxKind.ConditionalExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ConstructSignatureDeclaration.
     * @param node - Node to check.
     */
    static isConstructSignatureDeclaration(node: compiler.Node): node is compiler.ConstructSignatureDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.ConstructSignature:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ConstructorDeclaration.
     * @param node - Node to check.
     */
    static isConstructorDeclaration(node: compiler.Node): node is compiler.ConstructorDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ConstructorTypeNode.
     * @param node - Node to check.
     */
    static isConstructorTypeNode(node: compiler.Node): node is compiler.ConstructorTypeNode {
        switch (node.getKind()) {
            case SyntaxKind.ConstructorType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ContinueStatement.
     * @param node - Node to check.
     */
    static isContinueStatement(node: compiler.Node): node is compiler.ContinueStatement {
        switch (node.getKind()) {
            case SyntaxKind.ContinueStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a DebuggerStatement.
     * @param node - Node to check.
     */
    static isDebuggerStatement(node: compiler.Node): node is compiler.DebuggerStatement {
        switch (node.getKind()) {
            case SyntaxKind.DebuggerStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a DeclarationNamedNode.
     * @param node - Node to check.
     */
    static isDeclarationNamedNode(node: compiler.Node): node is compiler.DeclarationNamedNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.Parameter:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a DecoratableNode.
     * @param node - Node to check.
     */
    static isDecoratableNode(node: compiler.Node): node is compiler.DecoratableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.Parameter:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a Decorator.
     * @param node - Node to check.
     */
    static isDecorator(node: compiler.Node): node is compiler.Decorator {
        switch (node.getKind()) {
            case SyntaxKind.Decorator:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a DefaultClause.
     * @param node - Node to check.
     */
    static isDefaultClause(node: compiler.Node): node is compiler.DefaultClause {
        switch (node.getKind()) {
            case SyntaxKind.DefaultClause:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a DeleteExpression.
     * @param node - Node to check.
     */
    static isDeleteExpression(node: compiler.Node): node is compiler.DeleteExpression {
        switch (node.getKind()) {
            case SyntaxKind.DeleteExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a DoStatement.
     * @param node - Node to check.
     */
    static isDoStatement(node: compiler.Node): node is compiler.DoStatement {
        switch (node.getKind()) {
            case SyntaxKind.DoStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ElementAccessExpression.
     * @param node - Node to check.
     */
    static isElementAccessExpression(node: compiler.Node): node is compiler.ElementAccessExpression {
        switch (node.getKind()) {
            case SyntaxKind.ElementAccessExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an EmptyStatement.
     * @param node - Node to check.
     */
    static isEmptyStatement(node: compiler.Node): node is compiler.EmptyStatement {
        switch (node.getKind()) {
            case SyntaxKind.EmptyStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an EnumDeclaration.
     * @param node - Node to check.
     */
    static isEnumDeclaration(node: compiler.Node): node is compiler.EnumDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.EnumDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an EnumMember.
     * @param node - Node to check.
     */
    static isEnumMember(node: compiler.Node): node is compiler.EnumMember {
        switch (node.getKind()) {
            case SyntaxKind.EnumMember:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExclamationTokenableNode.
     * @param node - Node to check.
     */
    static isExclamationTokenableNode(node: compiler.Node): node is compiler.ExclamationTokenableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExportAssignment.
     * @param node - Node to check.
     */
    static isExportAssignment(node: compiler.Node): node is compiler.ExportAssignment {
        switch (node.getKind()) {
            case SyntaxKind.ExportAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExportDeclaration.
     * @param node - Node to check.
     */
    static isExportDeclaration(node: compiler.Node): node is compiler.ExportDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.ExportDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExportSpecifier.
     * @param node - Node to check.
     */
    static isExportSpecifier(node: compiler.Node): node is compiler.ExportSpecifier {
        switch (node.getKind()) {
            case SyntaxKind.ExportSpecifier:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExportableNode.
     * @param node - Node to check.
     */
    static isExportableNode(node: compiler.Node): node is compiler.ExportableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an Expression.
     * @param node - Node to check.
     */
    static isExpression(node: compiler.Node): node is compiler.Expression {
        switch (node.getKind()) {
            case SyntaxKind.AnyKeyword:
            case SyntaxKind.BooleanKeyword:
            case SyntaxKind.NeverKeyword:
            case SyntaxKind.NumberKeyword:
            case SyntaxKind.ObjectKeyword:
            case SyntaxKind.StringKeyword:
            case SyntaxKind.SymbolKeyword:
            case SyntaxKind.UndefinedKeyword:
            case SyntaxKind.Identifier:
            case SyntaxKind.AsExpression:
            case SyntaxKind.AwaitExpression:
            case SyntaxKind.BinaryExpression:
            case SyntaxKind.CallExpression:
            case SyntaxKind.CommaListExpression:
            case SyntaxKind.ConditionalExpression:
            case SyntaxKind.DeleteExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.OmittedExpression:
            case SyntaxKind.ParenthesizedExpression:
            case SyntaxKind.PartiallyEmittedExpression:
            case SyntaxKind.PostfixUnaryExpression:
            case SyntaxKind.PrefixUnaryExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SpreadElement:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.TypeOfExpression:
            case SyntaxKind.VoidKeyword:
            case SyntaxKind.YieldExpression:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxClosingFragment:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxExpression:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxOpeningElement:
            case SyntaxKind.JsxOpeningFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.FirstLiteralToken:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExpressionStatement.
     * @param node - Node to check.
     */
    static isExpressionStatement(node: compiler.Node): node is compiler.ExpressionStatement {
        switch (node.getKind()) {
            case SyntaxKind.ExpressionStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExpressionWithTypeArguments.
     * @param node - Node to check.
     */
    static isExpressionWithTypeArguments(node: compiler.Node): node is compiler.ExpressionWithTypeArguments {
        switch (node.getKind()) {
            case SyntaxKind.ExpressionWithTypeArguments:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExpressionedNode.
     * @param node - Node to check.
     */
    static isExpressionedNode(node: compiler.Node): node is compiler.ExpressionedNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.AsExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.ParenthesizedExpression:
            case SyntaxKind.PartiallyEmittedExpression:
            case SyntaxKind.SpreadElement:
            case SyntaxKind.SpreadAssignment:
            case SyntaxKind.TemplateSpan:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExtendsClauseableNode.
     * @param node - Node to check.
     */
    static isExtendsClauseableNode(node: compiler.Node): node is compiler.ExtendsClauseableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.InterfaceDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExternalModuleReference.
     * @param node - Node to check.
     */
    static isExternalModuleReference(node: compiler.Node): node is compiler.ExternalModuleReference {
        switch (node.getKind()) {
            case SyntaxKind.ExternalModuleReference:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ForInStatement.
     * @param node - Node to check.
     */
    static isForInStatement(node: compiler.Node): node is compiler.ForInStatement {
        switch (node.getKind()) {
            case SyntaxKind.ForInStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ForOfStatement.
     * @param node - Node to check.
     */
    static isForOfStatement(node: compiler.Node): node is compiler.ForOfStatement {
        switch (node.getKind()) {
            case SyntaxKind.ForOfStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ForStatement.
     * @param node - Node to check.
     */
    static isForStatement(node: compiler.Node): node is compiler.ForStatement {
        switch (node.getKind()) {
            case SyntaxKind.ForStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a FunctionDeclaration.
     * @param node - Node to check.
     */
    static isFunctionDeclaration(node: compiler.Node): node is compiler.FunctionDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a FunctionExpression.
     * @param node - Node to check.
     */
    static isFunctionExpression(node: compiler.Node): node is compiler.FunctionExpression {
        switch (node.getKind()) {
            case SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a FunctionLikeDeclaration.
     * @param node - Node to check.
     */
    static isFunctionLikeDeclaration(node: compiler.Node): node is compiler.FunctionLikeDeclaration & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a FunctionTypeNode.
     * @param node - Node to check.
     */
    static isFunctionTypeNode(node: compiler.Node): node is compiler.FunctionTypeNode {
        switch (node.getKind()) {
            case SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a GeneratorableNode.
     * @param node - Node to check.
     */
    static isGeneratorableNode(node: compiler.Node): node is compiler.GeneratorableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.YieldExpression:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a GetAccessorDeclaration.
     * @param node - Node to check.
     */
    static isGetAccessorDeclaration(node: compiler.Node): node is compiler.GetAccessorDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.GetAccessor:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a HeritageClause.
     * @param node - Node to check.
     */
    static isHeritageClause(node: compiler.Node): node is compiler.HeritageClause {
        switch (node.getKind()) {
            case SyntaxKind.HeritageClause:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a HeritageClauseableNode.
     * @param node - Node to check.
     */
    static isHeritageClauseableNode(node: compiler.Node): node is compiler.HeritageClauseableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.InterfaceDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a Identifier.
     * @param node - Node to check.
     */
    static isIdentifier(node: compiler.Node): node is compiler.Identifier {
        switch (node.getKind()) {
            case SyntaxKind.Identifier:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a IfStatement.
     * @param node - Node to check.
     */
    static isIfStatement(node: compiler.Node): node is compiler.IfStatement {
        switch (node.getKind()) {
            case SyntaxKind.IfStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ImplementsClauseableNode.
     * @param node - Node to check.
     */
    static isImplementsClauseableNode(node: compiler.Node): node is compiler.ImplementsClauseableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ImportDeclaration.
     * @param node - Node to check.
     */
    static isImportDeclaration(node: compiler.Node): node is compiler.ImportDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.ImportDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ImportEqualsDeclaration.
     * @param node - Node to check.
     */
    static isImportEqualsDeclaration(node: compiler.Node): node is compiler.ImportEqualsDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.ImportEqualsDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ImportExpression.
     * @param node - Node to check.
     */
    static isImportExpression(node: compiler.Node): node is compiler.ImportExpression {
        switch (node.getKind()) {
            case SyntaxKind.ImportKeyword:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ImportSpecifier.
     * @param node - Node to check.
     */
    static isImportSpecifier(node: compiler.Node): node is compiler.ImportSpecifier {
        switch (node.getKind()) {
            case SyntaxKind.ImportSpecifier:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a IndexSignatureDeclaration.
     * @param node - Node to check.
     */
    static isIndexSignatureDeclaration(node: compiler.Node): node is compiler.IndexSignatureDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.IndexSignature:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a InitializerExpressionableNode.
     * @param node - Node to check.
     */
    static isInitializerExpressionableNode(node: compiler.Node): node is compiler.InitializerExpressionableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.Parameter:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a InitializerGetExpressionableNode.
     * @param node - Node to check.
     */
    static isInitializerGetExpressionableNode(node: compiler.Node): node is compiler.InitializerGetExpressionableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.Parameter:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.VariableDeclaration:
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a InitializerSetExpressionableNode.
     * @param node - Node to check.
     */
    static isInitializerSetExpressionableNode(node: compiler.Node): node is compiler.InitializerSetExpressionableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.Parameter:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a InterfaceDeclaration.
     * @param node - Node to check.
     */
    static isInterfaceDeclaration(node: compiler.Node): node is compiler.InterfaceDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.InterfaceDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a IntersectionTypeNode.
     * @param node - Node to check.
     */
    static isIntersectionTypeNode(node: compiler.Node): node is compiler.IntersectionTypeNode {
        switch (node.getKind()) {
            case SyntaxKind.IntersectionType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a IterationStatement.
     * @param node - Node to check.
     */
    static isIterationStatement(node: compiler.Node): node is compiler.IterationStatement {
        switch (node.getKind()) {
            case SyntaxKind.DoStatement:
            case SyntaxKind.ForInStatement:
            case SyntaxKind.ForOfStatement:
            case SyntaxKind.ForStatement:
            case SyntaxKind.WhileStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDoc.
     * @param node - Node to check.
     */
    static isJSDoc(node: compiler.Node): node is compiler.JSDoc {
        switch (node.getKind()) {
            case SyntaxKind.JSDocComment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocAugmentsTag.
     * @param node - Node to check.
     */
    static isJSDocAugmentsTag(node: compiler.Node): node is compiler.JSDocAugmentsTag {
        switch (node.getKind()) {
            case SyntaxKind.JSDocAugmentsTag:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocClassTag.
     * @param node - Node to check.
     */
    static isJSDocClassTag(node: compiler.Node): node is compiler.JSDocClassTag {
        switch (node.getKind()) {
            case SyntaxKind.JSDocClassTag:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocParameterTag.
     * @param node - Node to check.
     */
    static isJSDocParameterTag(node: compiler.Node): node is compiler.JSDocParameterTag {
        switch (node.getKind()) {
            case SyntaxKind.JSDocParameterTag:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocPropertyLikeTag.
     * @param node - Node to check.
     */
    static isJSDocPropertyLikeTag(node: compiler.Node): node is compiler.JSDocPropertyLikeTag & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.JSDocParameterTag:
            case SyntaxKind.JSDocPropertyTag:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocPropertyTag.
     * @param node - Node to check.
     */
    static isJSDocPropertyTag(node: compiler.Node): node is compiler.JSDocPropertyTag {
        switch (node.getKind()) {
            case SyntaxKind.JSDocPropertyTag:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocReturnTag.
     * @param node - Node to check.
     */
    static isJSDocReturnTag(node: compiler.Node): node is compiler.JSDocReturnTag {
        switch (node.getKind()) {
            case SyntaxKind.JSDocReturnTag:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocTag.
     * @param node - Node to check.
     */
    static isJSDocTag(node: compiler.Node): node is compiler.JSDocTag {
        switch (node.getKind()) {
            case SyntaxKind.JSDocAugmentsTag:
            case SyntaxKind.JSDocClassTag:
            case SyntaxKind.JSDocParameterTag:
            case SyntaxKind.JSDocPropertyTag:
            case SyntaxKind.JSDocReturnTag:
            case SyntaxKind.JSDocTypedefTag:
            case SyntaxKind.JSDocTypeTag:
            case SyntaxKind.JSDocTag:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocTypeTag.
     * @param node - Node to check.
     */
    static isJSDocTypeTag(node: compiler.Node): node is compiler.JSDocTypeTag {
        switch (node.getKind()) {
            case SyntaxKind.JSDocTypeTag:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocTypedefTag.
     * @param node - Node to check.
     */
    static isJSDocTypedefTag(node: compiler.Node): node is compiler.JSDocTypedefTag {
        switch (node.getKind()) {
            case SyntaxKind.JSDocTypedefTag:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocUnknownTag.
     * @param node - Node to check.
     */
    static isJSDocUnknownTag(node: compiler.Node): node is compiler.JSDocUnknownTag {
        switch (node.getKind()) {
            case SyntaxKind.JSDocTag:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocableNode.
     * @param node - Node to check.
     */
    static isJSDocableNode(node: compiler.Node): node is compiler.JSDocableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.ExpressionStatement:
            case SyntaxKind.LabeledStatement:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxAttribute.
     * @param node - Node to check.
     */
    static isJsxAttribute(node: compiler.Node): node is compiler.JsxAttribute {
        switch (node.getKind()) {
            case SyntaxKind.JsxAttribute:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxClosingElement.
     * @param node - Node to check.
     */
    static isJsxClosingElement(node: compiler.Node): node is compiler.JsxClosingElement {
        switch (node.getKind()) {
            case SyntaxKind.JsxClosingElement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxClosingFragment.
     * @param node - Node to check.
     */
    static isJsxClosingFragment(node: compiler.Node): node is compiler.JsxClosingFragment {
        switch (node.getKind()) {
            case SyntaxKind.JsxClosingFragment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxElement.
     * @param node - Node to check.
     */
    static isJsxElement(node: compiler.Node): node is compiler.JsxElement {
        switch (node.getKind()) {
            case SyntaxKind.JsxElement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxExpression.
     * @param node - Node to check.
     */
    static isJsxExpression(node: compiler.Node): node is compiler.JsxExpression {
        switch (node.getKind()) {
            case SyntaxKind.JsxExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxFragment.
     * @param node - Node to check.
     */
    static isJsxFragment(node: compiler.Node): node is compiler.JsxFragment {
        switch (node.getKind()) {
            case SyntaxKind.JsxFragment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxOpeningElement.
     * @param node - Node to check.
     */
    static isJsxOpeningElement(node: compiler.Node): node is compiler.JsxOpeningElement {
        switch (node.getKind()) {
            case SyntaxKind.JsxOpeningElement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxOpeningFragment.
     * @param node - Node to check.
     */
    static isJsxOpeningFragment(node: compiler.Node): node is compiler.JsxOpeningFragment {
        switch (node.getKind()) {
            case SyntaxKind.JsxOpeningFragment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxSelfClosingElement.
     * @param node - Node to check.
     */
    static isJsxSelfClosingElement(node: compiler.Node): node is compiler.JsxSelfClosingElement {
        switch (node.getKind()) {
            case SyntaxKind.JsxSelfClosingElement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxSpreadAttribute.
     * @param node - Node to check.
     */
    static isJsxSpreadAttribute(node: compiler.Node): node is compiler.JsxSpreadAttribute {
        switch (node.getKind()) {
            case SyntaxKind.JsxSpreadAttribute:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxText.
     * @param node - Node to check.
     */
    static isJsxText(node: compiler.Node): node is compiler.JsxText {
        switch (node.getKind()) {
            case SyntaxKind.JsxText:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a LabeledStatement.
     * @param node - Node to check.
     */
    static isLabeledStatement(node: compiler.Node): node is compiler.LabeledStatement {
        switch (node.getKind()) {
            case SyntaxKind.LabeledStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a LeftHandSideExpression.
     * @param node - Node to check.
     */
    static isLeftHandSideExpression(node: compiler.Node): node is compiler.LeftHandSideExpression {
        switch (node.getKind()) {
            case SyntaxKind.Identifier:
            case SyntaxKind.CallExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.FirstLiteralToken:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a LeftHandSideExpressionedNode.
     * @param node - Node to check.
     */
    static isLeftHandSideExpressionedNode(node: compiler.Node): node is compiler.LeftHandSideExpressionedNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.CallExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.NewExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.ExpressionWithTypeArguments:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a LiteralExpression.
     * @param node - Node to check.
     */
    static isLiteralExpression(node: compiler.Node): node is compiler.LiteralExpression {
        switch (node.getKind()) {
            case SyntaxKind.FirstLiteralToken:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a LiteralLikeNode.
     * @param node - Node to check.
     */
    static isLiteralLikeNode(node: compiler.Node): node is compiler.LiteralLikeNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.FirstLiteralToken:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TemplateHead:
            case SyntaxKind.TemplateMiddle:
            case SyntaxKind.TemplateTail:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a LiteralTypeNode.
     * @param node - Node to check.
     */
    static isLiteralTypeNode(node: compiler.Node): node is compiler.LiteralTypeNode {
        switch (node.getKind()) {
            case SyntaxKind.LiteralType:
            case SyntaxKind.LastTypeNode:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a MemberExpression.
     * @param node - Node to check.
     */
    static isMemberExpression(node: compiler.Node): node is compiler.MemberExpression {
        switch (node.getKind()) {
            case SyntaxKind.Identifier:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.FirstLiteralToken:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a MetaProperty.
     * @param node - Node to check.
     */
    static isMetaProperty(node: compiler.Node): node is compiler.MetaProperty {
        switch (node.getKind()) {
            case SyntaxKind.MetaProperty:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a MethodDeclaration.
     * @param node - Node to check.
     */
    static isMethodDeclaration(node: compiler.Node): node is compiler.MethodDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.MethodDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a MethodSignature.
     * @param node - Node to check.
     */
    static isMethodSignature(node: compiler.Node): node is compiler.MethodSignature {
        switch (node.getKind()) {
            case SyntaxKind.MethodSignature:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ModifierableNode.
     * @param node - Node to check.
     */
    static isModifierableNode(node: compiler.Node): node is compiler.ModifierableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.Parameter:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.VariableDeclarationList:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NameableNode.
     * @param node - Node to check.
     */
    static isNameableNode(node: compiler.Node): node is compiler.NameableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NamedNode.
     * @param node - Node to check.
     */
    static isNamedNode(node: compiler.Node): node is compiler.NamedNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.JsxAttribute:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.TypeParameter:
            case SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NamespaceChildableNode.
     * @param node - Node to check.
     */
    static isNamespaceChildableNode(node: compiler.Node): node is compiler.NamespaceChildableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.VariableStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NamespaceDeclaration.
     * @param node - Node to check.
     */
    static isNamespaceDeclaration(node: compiler.Node): node is compiler.NamespaceDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NewExpression.
     * @param node - Node to check.
     */
    static isNewExpression(node: compiler.Node): node is compiler.NewExpression {
        switch (node.getKind()) {
            case SyntaxKind.NewExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NoSubstitutionTemplateLiteral.
     * @param node - Node to check.
     */
    static isNoSubstitutionTemplateLiteral(node: compiler.Node): node is compiler.NoSubstitutionTemplateLiteral {
        switch (node.getKind()) {
            case SyntaxKind.NoSubstitutionTemplateLiteral:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NonNullExpression.
     * @param node - Node to check.
     */
    static isNonNullExpression(node: compiler.Node): node is compiler.NonNullExpression {
        switch (node.getKind()) {
            case SyntaxKind.NonNullExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NotEmittedStatement.
     * @param node - Node to check.
     */
    static isNotEmittedStatement(node: compiler.Node): node is compiler.NotEmittedStatement {
        switch (node.getKind()) {
            case SyntaxKind.NotEmittedStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NullLiteral.
     * @param node - Node to check.
     */
    static isNullLiteral(node: compiler.Node): node is compiler.NullLiteral {
        switch (node.getKind()) {
            case SyntaxKind.NullKeyword:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NumericLiteral.
     * @param node - Node to check.
     */
    static isNumericLiteral(node: compiler.Node): node is compiler.NumericLiteral {
        switch (node.getKind()) {
            case SyntaxKind.FirstLiteralToken:
            case SyntaxKind.NumericLiteral:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ObjectLiteralExpression.
     * @param node - Node to check.
     */
    static isObjectLiteralExpression(node: compiler.Node): node is compiler.ObjectLiteralExpression {
        switch (node.getKind()) {
            case SyntaxKind.ObjectLiteralExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a OmittedExpression.
     * @param node - Node to check.
     */
    static isOmittedExpression(node: compiler.Node): node is compiler.OmittedExpression {
        switch (node.getKind()) {
            case SyntaxKind.OmittedExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a OverloadableNode.
     * @param node - Node to check.
     */
    static isOverloadableNode(node: compiler.Node): node is compiler.OverloadableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ParameterDeclaration.
     * @param node - Node to check.
     */
    static isParameterDeclaration(node: compiler.Node): node is compiler.ParameterDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.Parameter:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ParameteredNode.
     * @param node - Node to check.
     */
    static isParameteredNode(node: compiler.Node): node is compiler.ParameteredNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.ConstructorType:
            case SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ParenthesizedExpression.
     * @param node - Node to check.
     */
    static isParenthesizedExpression(node: compiler.Node): node is compiler.ParenthesizedExpression {
        switch (node.getKind()) {
            case SyntaxKind.ParenthesizedExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a PartiallyEmittedExpression.
     * @param node - Node to check.
     */
    static isPartiallyEmittedExpression(node: compiler.Node): node is compiler.PartiallyEmittedExpression {
        switch (node.getKind()) {
            case SyntaxKind.PartiallyEmittedExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a PostfixUnaryExpression.
     * @param node - Node to check.
     */
    static isPostfixUnaryExpression(node: compiler.Node): node is compiler.PostfixUnaryExpression {
        switch (node.getKind()) {
            case SyntaxKind.PostfixUnaryExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a PrefixUnaryExpression.
     * @param node - Node to check.
     */
    static isPrefixUnaryExpression(node: compiler.Node): node is compiler.PrefixUnaryExpression {
        switch (node.getKind()) {
            case SyntaxKind.PrefixUnaryExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a PrimaryExpression.
     * @param node - Node to check.
     */
    static isPrimaryExpression(node: compiler.Node): node is compiler.PrimaryExpression {
        switch (node.getKind()) {
            case SyntaxKind.Identifier:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.FirstLiteralToken:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a PropertyAccessExpression.
     * @param node - Node to check.
     */
    static isPropertyAccessExpression(node: compiler.Node): node is compiler.PropertyAccessExpression {
        switch (node.getKind()) {
            case SyntaxKind.PropertyAccessExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a PropertyAssignment.
     * @param node - Node to check.
     */
    static isPropertyAssignment(node: compiler.Node): node is compiler.PropertyAssignment {
        switch (node.getKind()) {
            case SyntaxKind.PropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a PropertyDeclaration.
     * @param node - Node to check.
     */
    static isPropertyDeclaration(node: compiler.Node): node is compiler.PropertyDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.PropertyDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a PropertyNamedNode.
     * @param node - Node to check.
     */
    static isPropertyNamedNode(node: compiler.Node): node is compiler.PropertyNamedNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumMember:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.PropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a PropertySignature.
     * @param node - Node to check.
     */
    static isPropertySignature(node: compiler.Node): node is compiler.PropertySignature {
        switch (node.getKind()) {
            case SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a QualifiedName.
     * @param node - Node to check.
     */
    static isQualifiedName(node: compiler.Node): node is compiler.QualifiedName {
        switch (node.getKind()) {
            case SyntaxKind.FirstNode:
            case SyntaxKind.QualifiedName:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a QuestionTokenableNode.
     * @param node - Node to check.
     */
    static isQuestionTokenableNode(node: compiler.Node): node is compiler.QuestionTokenableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.Parameter:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ReadonlyableNode.
     * @param node - Node to check.
     */
    static isReadonlyableNode(node: compiler.Node): node is compiler.ReadonlyableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.Parameter:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a RegularExpressionLiteral.
     * @param node - Node to check.
     */
    static isRegularExpressionLiteral(node: compiler.Node): node is compiler.RegularExpressionLiteral {
        switch (node.getKind()) {
            case SyntaxKind.RegularExpressionLiteral:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ReturnStatement.
     * @param node - Node to check.
     */
    static isReturnStatement(node: compiler.Node): node is compiler.ReturnStatement {
        switch (node.getKind()) {
            case SyntaxKind.ReturnStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ReturnTypedNode.
     * @param node - Node to check.
     */
    static isReturnTypedNode(node: compiler.Node): node is compiler.ReturnTypedNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.ConstructorType:
            case SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ScopeableNode.
     * @param node - Node to check.
     */
    static isScopeableNode(node: compiler.Node): node is compiler.ScopeableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.Parameter:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ScopedNode.
     * @param node - Node to check.
     */
    static isScopedNode(node: compiler.Node): node is compiler.ScopedNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a SemicolonToken.
     * @param node - Node to check.
     */
    static isSemicolonToken(node: compiler.Node): node is compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.SemicolonToken:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a SetAccessorDeclaration.
     * @param node - Node to check.
     */
    static isSetAccessorDeclaration(node: compiler.Node): node is compiler.SetAccessorDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ShorthandPropertyAssignment.
     * @param node - Node to check.
     */
    static isShorthandPropertyAssignment(node: compiler.Node): node is compiler.ShorthandPropertyAssignment {
        switch (node.getKind()) {
            case SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a SignaturedDeclaration.
     * @param node - Node to check.
     */
    static isSignaturedDeclaration(node: compiler.Node): node is compiler.SignaturedDeclaration & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.ConstructorType:
            case SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a SourceFile.
     * @param node - Node to check.
     */
    static isSourceFile(node: compiler.Node): node is compiler.SourceFile {
        switch (node.getKind()) {
            case SyntaxKind.SourceFile:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a SpreadAssignment.
     * @param node - Node to check.
     */
    static isSpreadAssignment(node: compiler.Node): node is compiler.SpreadAssignment {
        switch (node.getKind()) {
            case SyntaxKind.SpreadAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a SpreadElement.
     * @param node - Node to check.
     */
    static isSpreadElement(node: compiler.Node): node is compiler.SpreadElement {
        switch (node.getKind()) {
            case SyntaxKind.SpreadElement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a Statement.
     * @param node - Node to check.
     */
    static isStatement(node: compiler.Node): node is compiler.Statement {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.ExportAssignment:
            case SyntaxKind.ExportDeclaration:
            case SyntaxKind.ImportDeclaration:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.Block:
            case SyntaxKind.BreakStatement:
            case SyntaxKind.ContinueStatement:
            case SyntaxKind.DebuggerStatement:
            case SyntaxKind.DoStatement:
            case SyntaxKind.EmptyStatement:
            case SyntaxKind.ExpressionStatement:
            case SyntaxKind.ForInStatement:
            case SyntaxKind.ForOfStatement:
            case SyntaxKind.ForStatement:
            case SyntaxKind.IfStatement:
            case SyntaxKind.LabeledStatement:
            case SyntaxKind.NotEmittedStatement:
            case SyntaxKind.ReturnStatement:
            case SyntaxKind.SwitchStatement:
            case SyntaxKind.ThrowStatement:
            case SyntaxKind.TryStatement:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.WhileStatement:
            case SyntaxKind.WithStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a StatementedNode.
     * @param node - Node to check.
     */
    static isStatementedNode(node: compiler.Node): node is compiler.StatementedNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.SourceFile:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.Block:
            case SyntaxKind.CaseClause:
            case SyntaxKind.DefaultClause:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a StaticableNode.
     * @param node - Node to check.
     */
    static isStaticableNode(node: compiler.Node): node is compiler.StaticableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a StringLiteral.
     * @param node - Node to check.
     */
    static isStringLiteral(node: compiler.Node): node is compiler.StringLiteral {
        switch (node.getKind()) {
            case SyntaxKind.StringLiteral:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a SuperExpression.
     * @param node - Node to check.
     */
    static isSuperExpression(node: compiler.Node): node is compiler.SuperExpression {
        switch (node.getKind()) {
            case SyntaxKind.SuperKeyword:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a SwitchStatement.
     * @param node - Node to check.
     */
    static isSwitchStatement(node: compiler.Node): node is compiler.SwitchStatement {
        switch (node.getKind()) {
            case SyntaxKind.SwitchStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a SyntaxList.
     * @param node - Node to check.
     */
    static isSyntaxList(node: compiler.Node): node is compiler.SyntaxList {
        switch (node.getKind()) {
            case SyntaxKind.SyntaxList:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TaggedTemplateExpression.
     * @param node - Node to check.
     */
    static isTaggedTemplateExpression(node: compiler.Node): node is compiler.TaggedTemplateExpression {
        switch (node.getKind()) {
            case SyntaxKind.TaggedTemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TemplateExpression.
     * @param node - Node to check.
     */
    static isTemplateExpression(node: compiler.Node): node is compiler.TemplateExpression {
        switch (node.getKind()) {
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TemplateHead.
     * @param node - Node to check.
     */
    static isTemplateHead(node: compiler.Node): node is compiler.TemplateHead {
        switch (node.getKind()) {
            case SyntaxKind.TemplateHead:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TemplateMiddle.
     * @param node - Node to check.
     */
    static isTemplateMiddle(node: compiler.Node): node is compiler.TemplateMiddle {
        switch (node.getKind()) {
            case SyntaxKind.TemplateMiddle:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TemplateSpan.
     * @param node - Node to check.
     */
    static isTemplateSpan(node: compiler.Node): node is compiler.TemplateSpan {
        switch (node.getKind()) {
            case SyntaxKind.TemplateSpan:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TemplateTail.
     * @param node - Node to check.
     */
    static isTemplateTail(node: compiler.Node): node is compiler.TemplateTail {
        switch (node.getKind()) {
            case SyntaxKind.TemplateTail:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TextInsertableNode.
     * @param node - Node to check.
     */
    static isTextInsertableNode(node: compiler.Node): node is compiler.TextInsertableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.SourceFile:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.Block:
            case SyntaxKind.CaseBlock:
            case SyntaxKind.CaseClause:
            case SyntaxKind.DefaultClause:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ThisExpression.
     * @param node - Node to check.
     */
    static isThisExpression(node: compiler.Node): node is compiler.ThisExpression {
        switch (node.getKind()) {
            case SyntaxKind.ThisKeyword:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ThrowStatement.
     * @param node - Node to check.
     */
    static isThrowStatement(node: compiler.Node): node is compiler.ThrowStatement {
        switch (node.getKind()) {
            case SyntaxKind.ThrowStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TryStatement.
     * @param node - Node to check.
     */
    static isTryStatement(node: compiler.Node): node is compiler.TryStatement {
        switch (node.getKind()) {
            case SyntaxKind.TryStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TupleTypeNode.
     * @param node - Node to check.
     */
    static isTupleTypeNode(node: compiler.Node): node is compiler.TupleTypeNode {
        switch (node.getKind()) {
            case SyntaxKind.TupleType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeAliasDeclaration.
     * @param node - Node to check.
     */
    static isTypeAliasDeclaration(node: compiler.Node): node is compiler.TypeAliasDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeArgumentedNode.
     * @param node - Node to check.
     */
    static isTypeArgumentedNode(node: compiler.Node): node is compiler.TypeArgumentedNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.CallExpression:
            case SyntaxKind.NewExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeAssertion.
     * @param node - Node to check.
     */
    static isTypeAssertion(node: compiler.Node): node is compiler.TypeAssertion {
        switch (node.getKind()) {
            case SyntaxKind.TypeAssertionExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeElement.
     * @param node - Node to check.
     */
    static isTypeElement(node: compiler.Node): node is compiler.TypeElement {
        switch (node.getKind()) {
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeElementMemberedNode.
     * @param node - Node to check.
     */
    static isTypeElementMemberedNode(node: compiler.Node): node is compiler.TypeElementMemberedNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.TypeLiteral:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeLiteralNode.
     * @param node - Node to check.
     */
    static isTypeLiteralNode(node: compiler.Node): node is compiler.TypeLiteralNode {
        switch (node.getKind()) {
            case SyntaxKind.TypeLiteral:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeNode.
     * @param node - Node to check.
     */
    static isTypeNode(node: compiler.Node): node is compiler.TypeNode {
        switch (node.getKind()) {
            case SyntaxKind.FirstTypeNode:
            case SyntaxKind.ArrayType:
            case SyntaxKind.ConstructorType:
            case SyntaxKind.ExpressionWithTypeArguments:
            case SyntaxKind.FunctionType:
            case SyntaxKind.IntersectionType:
            case SyntaxKind.LiteralType:
            case SyntaxKind.LastTypeNode:
            case SyntaxKind.TupleType:
            case SyntaxKind.TypeLiteral:
            case SyntaxKind.TypeReference:
            case SyntaxKind.UnionType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeOfExpression.
     * @param node - Node to check.
     */
    static isTypeOfExpression(node: compiler.Node): node is compiler.TypeOfExpression {
        switch (node.getKind()) {
            case SyntaxKind.TypeOfExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeParameterDeclaration.
     * @param node - Node to check.
     */
    static isTypeParameterDeclaration(node: compiler.Node): node is compiler.TypeParameterDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.TypeParameter:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeParameteredNode.
     * @param node - Node to check.
     */
    static isTypeParameteredNode(node: compiler.Node): node is compiler.TypeParameteredNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.FunctionType:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeReferenceNode.
     * @param node - Node to check.
     */
    static isTypeReferenceNode(node: compiler.Node): node is compiler.TypeReferenceNode {
        switch (node.getKind()) {
            case SyntaxKind.TypeReference:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypedNode.
     * @param node - Node to check.
     */
    static isTypedNode(node: compiler.Node): node is compiler.TypedNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.AsExpression:
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.Parameter:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.VariableDeclaration:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a UnaryExpression.
     * @param node - Node to check.
     */
    static isUnaryExpression(node: compiler.Node): node is compiler.UnaryExpression {
        switch (node.getKind()) {
            case SyntaxKind.Identifier:
            case SyntaxKind.AwaitExpression:
            case SyntaxKind.CallExpression:
            case SyntaxKind.DeleteExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.PostfixUnaryExpression:
            case SyntaxKind.PrefixUnaryExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.TypeOfExpression:
            case SyntaxKind.VoidKeyword:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.FirstLiteralToken:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a UnaryExpressionedNode.
     * @param node - Node to check.
     */
    static isUnaryExpressionedNode(node: compiler.Node): node is compiler.UnaryExpressionedNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.AwaitExpression:
            case SyntaxKind.DeleteExpression:
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.TypeOfExpression:
            case SyntaxKind.VoidKeyword:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a UndefinedKeyword.
     * @param node - Node to check.
     */
    static isUndefinedKeyword(node: compiler.Node): node is compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.UndefinedKeyword:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a UnionTypeNode.
     * @param node - Node to check.
     */
    static isUnionTypeNode(node: compiler.Node): node is compiler.UnionTypeNode {
        switch (node.getKind()) {
            case SyntaxKind.UnionType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a UnwrappableNode.
     * @param node - Node to check.
     */
    static isUnwrappableNode(node: compiler.Node): node is compiler.UnwrappableNode & compiler.Node {
        switch (node.getKind()) {
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a UpdateExpression.
     * @param node - Node to check.
     */
    static isUpdateExpression(node: compiler.Node): node is compiler.UpdateExpression {
        switch (node.getKind()) {
            case SyntaxKind.Identifier:
            case SyntaxKind.CallExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.FirstLiteralToken:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a VariableDeclaration.
     * @param node - Node to check.
     */
    static isVariableDeclaration(node: compiler.Node): node is compiler.VariableDeclaration {
        switch (node.getKind()) {
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a VariableDeclarationList.
     * @param node - Node to check.
     */
    static isVariableDeclarationList(node: compiler.Node): node is compiler.VariableDeclarationList {
        switch (node.getKind()) {
            case SyntaxKind.VariableDeclarationList:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a VariableStatement.
     * @param node - Node to check.
     */
    static isVariableStatement(node: compiler.Node): node is compiler.VariableStatement {
        switch (node.getKind()) {
            case SyntaxKind.VariableStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a VoidExpression.
     * @param node - Node to check.
     */
    static isVoidExpression(node: compiler.Node): node is compiler.VoidExpression {
        switch (node.getKind()) {
            case SyntaxKind.VoidKeyword:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a WhileStatement.
     * @param node - Node to check.
     */
    static isWhileStatement(node: compiler.Node): node is compiler.WhileStatement {
        switch (node.getKind()) {
            case SyntaxKind.WhileStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a WithStatement.
     * @param node - Node to check.
     */
    static isWithStatement(node: compiler.Node): node is compiler.WithStatement {
        switch (node.getKind()) {
            case SyntaxKind.WithStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a YieldExpression.
     * @param node - Node to check.
     */
    static isYieldExpression(node: compiler.Node): node is compiler.YieldExpression {
        switch (node.getKind()) {
            case SyntaxKind.YieldExpression:
                return true;
            default:
                return false;
        }
    }
}

/**
 * Code generation: Create Node Polyfills
 * --------------------------------------
 * This creates a file that is being used as a temporary workaround so that this library
 * can be used with versions of the compiler < v2.7. In the future, a better solution should be devised.
 * --------------------------------------
 */
import * as path from "path";
import * as ts from "typescript";
import {rootFolder} from "./config";
import {InspectorFactory} from "./inspectors";
import {EnumDeclaration, EnumMemberStructure} from "./../src/main";

const nodesToPolyfillNames = ["JsxFragment", "JsxOpeningFragment", "JsxClosingFragment"];
const enumsToPolyfillNames = ["ScriptElementKind"];

export function createNodePolyfills(factory: InspectorFactory) {
    const tsInspector = factory.getTsInspector();
    const sourceFile = getSourceFile();

    sourceFile.addImportDeclaration({
        namespaceImport: "ts",
        moduleSpecifier: "typescript"
    });

    fillInterfaces();
    fillEnums();

    sourceFile.insertStatements(0, writer => {
        writer.writeLine("// DO NOT EDIT - This file is automatically generated by createNodePolyfills.ts");
        writer.writeLine("// This file is necessary because old supported versions of the compiler won't have these nodes.");
    });

    sourceFile.save();

    function getSourceFile() {
        const ast = factory.getAst();
        const filePath = path.join(rootFolder, "src/compiler/polyfills.ts");
        if (ast.getSourceFile(filePath) != null)
            ast.getSourceFileOrThrow(filePath).deleteSync();
        return ast.createSourceFile(filePath);
    }

    function fillInterfaces() {
        const nodesToPolyfill = tsInspector.getTsNodes().filter(n => nodesToPolyfillNames.indexOf(n.getName()) >= 0);
        for (const node of nodesToPolyfill) {
            const nodeInterface = node.getInterface();
            const newInterface = sourceFile.addInterface({
                name: nodeInterface.getName(),
                isExported: true,
                extends: nodeInterface.getExtends().map(e => e.getText())
            });

            for (const nodeProp of nodeInterface.getProperties()) {
                // don't include this because old versions of the compiler won't have the syntax kind
                if (nodeProp.getName() === "kind")
                    continue;

                newInterface.addProperty({
                    name: nodeProp.getName(),
                    type: nodeProp.getTypeNodeOrThrow().getText(),
                    hasQuestionToken: nodeProp.hasQuestionToken()
                });
            }
        }

        for (const newInterface of sourceFile.getInterfaces())
            newInterface.rename(newInterface.getName() + "CompilerPolyfill");

        // this is sketch, but good enough for now
        const prefix = "ts.";
        let offset = 0;
        for (const cannotFindNameDiagnostic of sourceFile.getDiagnostics().filter(d => d.getCode() === 2304)) {
            sourceFile.insertText(cannotFindNameDiagnostic.getStart()! + offset, prefix);
            offset += prefix.length;
        }
    }

    function fillEnums() {
        const enums = tsInspector.getDeclarationFile().getDescendantsOfKind(ts.SyntaxKind.EnumDeclaration) as EnumDeclaration[];
        const enumsToPolyfill = enums.filter(e => enumsToPolyfillNames.indexOf(e.getName()) >= 0);

        for (const enumDec of enumsToPolyfill) {
            sourceFile.addEnum({
                name: enumDec.getName(),
                isExported: true,
                members: enumDec.getMembers().map(m => ({
                    name: m.getName(),
                    docs: m.getJsDocs().map(d => ({ description: d.getInnerText().replace(/\r?\n/g, "\r\n") })),
                    value: m.getValue()
                }) as EnumMemberStructure)
            });
        }
    }
}

/**
 * Code Analysis - Output wrapped nodes info.
 * ------------------------------------------
 * This outputs information into wrapped-nodes.md saying what nodes have been wrapped and which ones haven't been.
 *
 * In the future, this should check which properites in the compiler haven't been used in this library by doing a "find references" on
 * all the compiler node properties.
 * ------------------------------------------
 */
import * as path from "path";
import * as fs from "fs";
import {rootFolder} from "./config";
import {InspectorFactory, TsNode} from "./inspectors";

// setup
const inspectorFactory = new InspectorFactory();
const tsSimpleAstInspector = inspectorFactory.getTsSimpleAstInspector();
const tsInspector = inspectorFactory.getTsInspector();

// get info
const wrappedNodes = tsSimpleAstInspector.getWrappedNodes();
const tsNodes = tsInspector.getTsNodes();

// figure out ts nodes that are wrapped and not wrapped
const wrappedTsNodes = tsNodes.filter(i => wrappedNodes.some(c => c.getAssociatedTsNodes().some(n => n === i)) || isImplementedViaMixins(i));
const notWrappedTsNodes = tsNodes.filter(i => wrappedTsNodes.indexOf(i) === -1 && !isIgnoredNode(i));

// output the results (todo: use a template for the output)
let output = "# Wrapped Nodes\n\n" +
    "This file is automatically generated and shows which nodes have been wrapped or not. " +
    "More information will be added to this in the future (ex. what properties are implemented or not for each node).\n\n";
outputCoverage("Exist", wrappedTsNodes);
output += "\n";
outputCoverage("Not Exist", notWrappedTsNodes);
fs.writeFileSync(path.join(rootFolder, "wrapped-nodes.md"), output);

function outputCoverage(header: string, tsNodesForOutput: TsNode[], additionalText?: string) {
    output += `## ${header}\n\n`;
    if (additionalText != null)
        output += additionalText + "\n\n";
    output += `**Total:** ${tsNodesForOutput.length}\n\n` +
        tsNodesForOutput.map(n => "* " + n.getName() + (isImplementedViaMixins(n) ? " - Implemented via mixin." : "")).join("\n") + "\n";
}

// config

function isIgnoredNode(node: TsNode) {
    switch (node.getName()) {
        // this would be implemented via a mixin
        case "Declaration":
            return true;
        default:
            return false;
    }
}

function isImplementedViaMixins(node: TsNode) {
    switch (node.getName()) {
        case "NamedDeclaration":
        case "FunctionLikeDeclarationBase":
        case "SignatureDeclarationBase":
            return true;
        default:
            return false;
    }
}

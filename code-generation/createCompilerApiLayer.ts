/**
 * Code generation: Create Compiler API Layer
 * ------------------------------------------
 * This creates a file that contains the typings from the TypeScript compiler API.
 * ------------------------------------------
 */
import * as path from "path";
import {rootFolder} from "./config";
import {InspectorFactory} from "./inspectors";
import {EnumDeclaration, InterfaceDeclaration, TypeAliasDeclaration, ClassDeclaration, TypeGuards, ts, SyntaxKind,
    UnionTypeNode} from "./../src/main";
import {cloneEnums, cloneInterfaces, cloneTypeAliases, cloneClasses} from "./common/cloning";

const enumsToSeparate = ["SyntaxKind", "ScriptTarget", "ScriptKind", "LanguageVariant", "EmitHint", "JsxEmit", "ModuleKind", "ModuleResolutionKind",
    "NewLineKind", "TypeFlags", "ObjectFlags", "SymbolFlags", "TypeFormatFlags", "DiagnosticCategory"];
const interfacesToSeparate = ["CompilerOptions", "MapLike"];
const typeAliasesToSeparate: string[] = [];

export function createCompilerApiLayer(factory: InspectorFactory) {
    const tsInspector = factory.getTsInspector();
    const ast = factory.getAst();
    const declarationFile = tsInspector.getDeclarationFile();

    const allEnums = declarationFile.getDescendantsOfKind(SyntaxKind.EnumDeclaration) as EnumDeclaration[];
    const allInterfaces = declarationFile.getDescendantsOfKind(SyntaxKind.InterfaceDeclaration) as InterfaceDeclaration[];
    const allTypeAliases = declarationFile.getDescendantsOfKind(SyntaxKind.TypeAliasDeclaration) as TypeAliasDeclaration[];

    createTsSourceFile();

    function createTsSourceFile() {
        const sourceFile = getOrCreateSourceFile("ts.ts");

        sourceFile.addImportDeclarations([{
            namespaceImport: "tsCompiler",
            moduleSpecifier: "typescript"
        }, {
            namedImports: [{ name: "ObjectUtils" }],
            moduleSpecifier: sourceFile.getRelativePathToSourceFileAsModuleSpecifier(ast.getSourceFileOrThrow("src/utils/ObjectUtils.ts"))
        }]);

        addSeparatedDeclarations();

        const tsNamespace = sourceFile.addNamespace({
            name: "ts",
            isExported: true
        });

        cloneInterfaces(tsNamespace, allInterfaces.filter(i => interfacesToSeparate.indexOf(i.getName()) === -1));
        cloneEnums(tsNamespace, allEnums.filter(e => enumsToSeparate.indexOf(e.getName()) === -1));
        cloneTypeAliases(tsNamespace, allTypeAliases.filter(t => typeAliasesToSeparate.indexOf(t.getName()) === -1));
        cloneClasses(tsNamespace, declarationFile.getDescendantsOfKind(SyntaxKind.ClassDeclaration) as ClassDeclaration[]);
        tsNamespace.getStatements().forEach(s => {
            if (TypeGuards.isAmbientableNode(s))
                s.setHasDeclareKeyword(true);
        });

        sourceFile.insertStatements(0, writer => {
            writer.writeLine("/* tslint:disable */");
            writer.writeLine("// DO NOT EDIT - This file is automatically generated by createCompilerApiLayer.ts");
        });

        tsNamespace.addStatements(writer => {
            writer.newLine();
            writer.writeLine("// overwrite this namespace with the TypeScript compiler");
            writer.write("ObjectUtils.assign((ts as any), tsCompiler);");
        });

        sourceFile.replaceWithText(sourceFile.getFullText().replace(/\r?\n/g, "\r\n"));

        sourceFile.save();

        function addSeparatedDeclarations() {
            for (const enumDec of allEnums.filter(e => enumsToSeparate.indexOf(e.getName()) >= 0))
                cloneEnums(sourceFile, [enumDec]);

            for (const interfaceDec of allInterfaces.filter(i => interfacesToSeparate.indexOf(i.getName()) >= 0))
                cloneInterfaces(sourceFile, [interfaceDec]);

            for (const typeAliasDec of allTypeAliases.filter(t => typeAliasesToSeparate.indexOf(t.getName()) >= 0))
                cloneTypeAliases(sourceFile, [typeAliasDec]);

            // todo: need a better way of doing this in the future...
            const returnTypeNode = sourceFile.getInterfaceOrThrow("CompilerOptions").getIndexSignatures()[0].getReturnTypeNode() as UnionTypeNode;
            returnTypeNode.getTypeNodes().map(n => {
                if (n.getText() === "CompilerOptionsValue" || n.getText() === "JsonSourceFile")
                    n.replaceWithText(`ts.${n.getText()}`);
            });
        }
    }

    function getOrCreateSourceFile(fileName: string) {
        const filePath = path.join(rootFolder, "src/typescript", fileName);
        const existingSourceFile = ast.getSourceFile(filePath);
        if (existingSourceFile != null)
            existingSourceFile.replaceWithText("");
        return existingSourceFile || ast.createSourceFile(filePath);
    }
}
